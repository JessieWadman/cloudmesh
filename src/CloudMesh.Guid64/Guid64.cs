using System.Buffers;
using System.Net.NetworkInformation;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;

#if (NET8_0_OR_GREATER)
    using System.IO.Hashing;
#else
    using CloudMesh.Utils;
#endif

namespace System
{

    // When to use: 
    //   * Use wherever you would normally use a Guid, but you need it to be time-sortable.
    //   * Use when you need the unique ID to be smaller than a Guid (i.e. when sending our IDs to external
    //     systems created by others who only allow us to send in a LONG, as opposed to a STRING.

    // When not to use: 
    //   * (Security) When you don't want users of the system to be able to construct timing analysis of the application
    //     to determine ingress rates, or be able to easily guess the next indice in a sequence (e.g. invoice numbers).
    public static class Guid64
    {
        // Twitter Snowflake
        // -----------------
        // Twitter snowflake generates 64-bit unique IDs at high scale. 
        // It can create up to 4096 unique ID's per machine per millisecond in a cluster of up to 1024 machines.

        // The IDs generated by this service are roughly time sortable.
        // The IDs are made up of the following components:
        // Epoch timestamp in millisecond precision - 41 bits (gives us 69 years with a custom epoch)
        // Configured machine id - 10 bits(gives us up to 1024 machines)
        // Sequence number - 12 bits(A local counter per machine that rolls over every 4096)

        private const int TotalBits = 64;
        private const int EpochBits = 42;
        private const int NodeIdBits = 10;
        private const int SequenceBits = 12;

        private const int MaxNodeId = (1 << NodeIdBits) - 1;
        private const long MaxSequence = (1 << SequenceBits) - 1;

        // Custom Epoch (January 1, 2015 Midnight UTC = 2015-01-01T00:00:00Z)
        private const long CustomEpoch = 1420070400000L;

        private static readonly long NodeId = CreateNodeId();

        private static long lastTimestamp = -1L;
        private static long sequence = 0L;

        [MethodImpl(MethodImplOptions.Synchronized)]
        public static long NewGuid()
        {
            var currentTimestamp = Timestamp();
            if (currentTimestamp < lastTimestamp)
            {
                for (var i = 0; i < 3; i++)
                {
                    currentTimestamp = WaitNextMillis(currentTimestamp);
                    sequence = 0L;
                    if (currentTimestamp > lastTimestamp)
                        break;
                }

                if (currentTimestamp < lastTimestamp)
                    throw new InvalidOperationException($"Invalid System Clock. Current timestamp {currentTimestamp} is before last timestamp {lastTimestamp}");
            }

            if (currentTimestamp == lastTimestamp)
            {
                sequence = (sequence + 1) & MaxSequence;
                if (sequence == 0)
                {
                    // Sequence Exhausted, wait till next millisecond.
                    currentTimestamp = WaitNextMillis(currentTimestamp);
                }
            }
            else
            {
                // reset sequence to start with zero for the next millisecond
                sequence = 0;
            }

            lastTimestamp = currentTimestamp;

            var id = currentTimestamp << (TotalBits - EpochBits);
            id |= (NodeId << (TotalBits - EpochBits - NodeIdBits));
            id |= sequence;
            return id;
        }

        // Get current timestamp in milliseconds, adjust for the custom epoch.
        private static long Timestamp()
            => DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - CustomEpoch;

        // Block and wait till next millisecond. Called when sequence numbers are 
        // exhausted within a millisecond. I.e. we create more than 4096 IDs per millisecond.
        private static long WaitNextMillis(long currentTimestamp)
        {
            while (currentTimestamp == lastTimestamp)
            {
                currentTimestamp = Timestamp();
            }
            return currentTimestamp;
        }

        private static int CreateNodeId()
        {
            int nodeId;
            try
            {
                var buffer = new ArrayBufferWriter<byte>();
                var networkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
                foreach (var networkInterface in networkInterfaces)
                {
                    var mac = networkInterface.GetPhysicalAddress().GetAddressBytes();
                    buffer.Write(mac);
                }
#if (NET8_0_OR_GREATER)
                nodeId = unchecked((int)XxHash32.HashToUInt32(buffer.WrittenSpan));
#else
                nodeId = MurmurHash.ByteHash(buffer.WrittenSpan.ToArray());  
#endif
            }
#pragma warning disable CA1031 // Do not catch general exception types
            catch
            {
                using var rng = RandomNumberGenerator.Create();
                var rand = new byte[sizeof(int)];
                rng.GetBytes(rand);
                nodeId = BitConverter.ToInt32(rand, 0);
            }
#pragma warning restore CA1031 // Do not catch general exception types

            nodeId &= MaxNodeId;
            return nodeId;
        }
    }
}
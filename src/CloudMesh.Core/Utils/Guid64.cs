using CloudMesh.Utils;
using System.Net.NetworkInformation;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;

namespace System
{

    // When to use: 
    //   * Use wherever you would normally use a Guid, but you need it to be time-sortable.
    //   * Use when you need the unique ID to be smallar than a Guid (i.e. when sending our IDs to external
    //     systems created by others who only allow us to send in a LONG, as opposed to a STRING.

    // When not to use: 
    //   * (Security) When you don't want users of the system to be able to construct timing analysis of the application
    //     to determine ingress rates, or be able to easily guess the next indice in a sequence (e.g. invoice numbers).
    public static class Guid64
    {
        // Twitter Snowflake
        // -----------------
        // Twitter snowflake generates 64-bit unique IDs at high scale. 
        // It can create up to 4096 unique ID's per machine per millisecond in a cluster of up to 1024 machines.

        // The IDs generated by this service are roughly time sortable.
        // The IDs are made up of the following components:
        // Epoch timestamp in millisecond precision - 41 bits (gives us 69 years with a custom epoch)
        // Configured machine id - 10 bits(gives us up to 1024 machines)
        // Sequence number - 12 bits(A local counter per machine that rolls over every 4096)

        private const int TOTAL_BITS = 64;
        private const int EPOCH_BITS = 42;
        private const int NODE_ID_BITS = 10;
        private const int SEQUENCE_BITS = 12;

        private const int maxNodeId = (1 << NODE_ID_BITS) - 1;
        private const long maxSequence = (1 << SEQUENCE_BITS) - 1;

        // Custom Epoch (January 1, 2015 Midnight UTC = 2015-01-01T00:00:00Z)
        private const long CUSTOM_EPOCH = 1420070400000L;

        private static readonly long nodeId = CreateNodeId();

        private static long lastTimestamp = -1L;
        private static long sequence = 0L;

        [MethodImpl(MethodImplOptions.Synchronized)]
        public static long NextId()
        {
            var currentTimestamp = Timestamp();
            if (currentTimestamp < lastTimestamp)
                throw new InvalidOperationException("Invalid System Clock!");

            if (currentTimestamp == lastTimestamp)
            {
                sequence = (sequence + 1) & maxSequence;
                if (sequence == 0)
                {
                    // Sequence Exhausted, wait till next millisecond.
                    currentTimestamp = WaitNextMillis(currentTimestamp);
                }
            }
            else
            {
                // reset sequence to start with zero for the next millisecond
                sequence = 0;
            }

            lastTimestamp = currentTimestamp;

            var id = currentTimestamp << (TOTAL_BITS - EPOCH_BITS);
            id |= (nodeId << (TOTAL_BITS - EPOCH_BITS - NODE_ID_BITS));
            id |= sequence;
            return id;
        }

        // Get current timestamp in milliseconds, adjust for the custom epoch.
        private static long Timestamp()
            => DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - CUSTOM_EPOCH;

        // Block and wait till next millisecond. Called when sequence numbers are 
        // exhausted within a millisecond. I.e. we create more than 4096 IDs per millisecond.
        private static long WaitNextMillis(long currentTimestamp)
        {
            while (currentTimestamp == lastTimestamp)
            {
                currentTimestamp = Timestamp();
            }
            return currentTimestamp;
        }

        private static int CreateNodeId()
        {
            int nodeId;
            try
            {
                var sb = new StringBuilder();
                var networkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
                foreach (var networkInterface in networkInterfaces)
                {
                    var mac = networkInterface.GetPhysicalAddress().GetAddressBytes();
                    if (mac != null)
                    {
                        for (var i = 0; i < mac.Length; i++)
                        {
                            sb.Append(mac[i].ToString("X"));
                        }
                    }
                }
                nodeId = MurmurHash.StringHash(sb.ToString());
            }
#pragma warning disable CA1031 // Do not catch general exception types
            catch
            {
                using var rng = RandomNumberGenerator.Create();
                var rand = new byte[sizeof(int)];
                rng.GetBytes(rand);
                nodeId = BitConverter.ToInt32(rand, 0);
            }
#pragma warning restore CA1031 // Do not catch general exception types

            nodeId &= maxNodeId;
            return nodeId;
        }
    }
}